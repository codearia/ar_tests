<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <title>AR Test Minimal</title>
  <style>
    body {
      margin: 0;
      background: black;
      font-family: sans-serif;
      overflow: hidden;
    }
    canvas {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: white;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      z-index: 100;
    }
    button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      font-size: 16px;
      z-index: 100;
      display: none;
    }
  </style>
</head>
<body>
  <div id='info'>Checking AR...</div>
  <button id='enter-ar'>ENTER AR</button>
  
  <script src='https://cdn.jsdelivr.net/npm/three@0.139.0/build/three.min.js'></script>
  <script>
    (function() {
      'use strict';
      
      let scene, camera, renderer, cube, reticle;
      let xrButton = document.getElementById('enter-ar');
      let info = document.getElementById('info');
      
      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        
        let light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);
        
        // Cube
        let geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        let material = new THREE.MeshPhongMaterial({color: 0x00ff00});
        cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 0, -0.5);
        scene.add(cube);
        
        // Reticle
        let reticleGeometry = new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2);
        let reticleMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
        reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
        
        renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        checkAR();
      }
      
      function checkAR() {
        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            if (supported) {
              xrButton.style.display = 'block';
              xrButton.addEventListener('click', onEnterAR);
              info.textContent = 'AR Ready!';
            } else {
              info.textContent = 'AR not supported';
            }
          });
        } else {
          info.textContent = 'WebXR not available';
        }
      }
      
      function onEnterAR() {
        let sessionInit = {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: {root: document.body}
        };
        
        navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
      }
      
      let hitTestSource = null;
      let localSpace = null;
      
      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);
        
        renderer.xr.setReferenceSpaceType('local');
        renderer.xr.setSession(session);
        
        xrButton.style.display = 'none';
        info.textContent = 'Point at surface';
        
        session.requestReferenceSpace('viewer').then((refSpace) => {
          session.requestHitTestSource({space: refSpace}).then((source) => {
            hitTestSource = source;
          });
        });
        
        session.requestReferenceSpace('local').then((refSpace) => {
          localSpace = refSpace;
          renderer.xr.setReferenceSpace(refSpace);
        });
      }
      
      function onSessionEnded() {
        hitTestSource = null;
        xrButton.style.display = 'block';
        info.textContent = 'AR Ready!';
      }
      
      let placed = false;
      
      function onSelect() {
        if (reticle.visible) {
          cube.position.setFromMatrixPosition(reticle.matrix);
          cube.visible = true;
          placed = true;
          info.textContent = 'Placed!';
        }
      }
      
      renderer.setAnimationLoop(function(time, frame) {
        if (frame) {
          let refSpace = renderer.xr.getReferenceSpace();
          
          if (hitTestSource && !placed) {
            let hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              let pose = hitTestResults[0].getPose(refSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
        }
        
        cube.rotation.x = time / 2000;
        cube.rotation.y = time / 1000;
        
        renderer.render(scene, camera);
      });
      
      init();
    })();
  </script>
</body>
</html>
